name: oci-free-a1-retry
on:
  schedule:
    - cron: '2-59/5 * * * *'   # toutes 5 min (décalé) en UTC
  workflow_dispatch:

permissions:
  contents: read

jobs:
  launch:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: oci-free-a1-retry
      cancel-in-progress: true

    env:
      # ===== VM1 =====
      VM1_DISPLAY_NAME: ${{ secrets.VM1_DISPLAY_NAME }}
      VM1_COMPARTMENT_ID: ${{ secrets.VM1_COMPARTMENT_ID }}
      VM1_SUBNET_ID: ${{ secrets.VM1_SUBNET_ID }}
      VM1_IMAGE_ID: ${{ secrets.VM1_IMAGE_ID }}
      VM1_OCPUS: "2"
      VM1_MEM_GB: "10"
      VM1_BOOT_SIZE_GB: "50"
      VM1_BOOT_VPUS_PER_GB: "10"
      VM1_ASSIGN_PUBLIC_IP: "false"
      VM1_SSH_AUTH_KEYS: ${{ secrets.SSH_AUTH_KEYS }}
      
      # ===== VM2 =====
      VM2_DISPLAY_NAME: ${{ secrets.VM2_DISPLAY_NAME }}
      VM2_COMPARTMENT_ID: ${{ secrets.VM1_COMPARTMENT_ID }}
      VM2_SUBNET_ID: ${{ secrets.VM1_SUBNET_ID }}
      VM2_IMAGE_ID: ${{ secrets.VM1_IMAGE_ID }}
      VM2_OCPUS: "2"
      VM2_MEM_GB: "14"
      VM2_BOOT_SIZE_GB: "50"
      VM2_BOOT_VPUS_PER_GB: "10"
      VM2_ASSIGN_PUBLIC_IP: "false"
      VM2_SSH_AUTH_KEYS: ${{ secrets.SSH_AUTH_KEYS }}

      # ===== Global =====
      AD_NAME: ${{ secrets.AD_NAME }}
      # Deadline dynamique vers le prochain créneau nominal du cron (2-59/5)
      CRON_OFFSET_MIN: "2"          # premier tir: minute 02
      CRON_PERIOD_MIN: "5"          # toutes les 5 minutes
      SAFETY_MARGIN_SEC: "45"       # marge pour ne pas chevaucher le prochain cron
      SLEEP_BETWEEN_ATTEMPTS_SEC: "45"
      JITTER_MAX_SEC: "10"          # +0–10s si 429

    steps:
      - name: Setup OCI CLI (no secret echo)
        env:
          OCI_TENANCY_OCID: ${{ secrets.OCI_TENANCY_OCID }}
          OCI_USER_OCID: ${{ secrets.OCI_USER_OCID }}
          OCI_FINGERPRINT: ${{ secrets.OCI_FINGERPRINT }}
          OCI_REGION: ${{ secrets.OCI_REGION }}
          OCI_PRIVATE_KEY: ${{ secrets.OCI_PRIVATE_KEY }}
        shell: bash
        run: |
          set -euo pipefail
          python3 -m pip install --user --upgrade oci-cli
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          export PATH="$HOME/.local/bin:$PATH"
          mkdir -p ~/.oci
          printf "[DEFAULT]\nuser=%s\ntenancy=%s\nfingerprint=%s\nregion=%s\nkey_file=%s\n" \
            "$OCI_USER_OCID" "$OCI_TENANCY_OCID" "$OCI_FINGERPRINT" "$OCI_REGION" "$HOME/.oci/oci_api_key.pem" \
            > ~/.oci/config
          umask 177 && printf "%s" "$OCI_PRIVATE_KEY" > ~/.oci/oci_api_key.pem
          oci -v

      - name: Launch VM1 then VM2 (dynamic deadline to next cron + 429-aware + full error logs)
        shell: bash
        run: |
          set -euo pipefail
          log(){ printf "%s %s\n" "$(date -Is)" "$*"; }

          # === Calcule une deadline dynamique: juste avant le prochain créneau du cron (UTC) ===
          PERIOD=${CRON_PERIOD_MIN:-5}
          OFFSET=${CRON_OFFSET_MIN:-2}
          MARGIN=${SAFETY_MARGIN_SEC:-45}

          now_ts=$(date -u +%s)
          min=$(date -u +%M); sec=$(date -u +%S)
          min=$((10#$min)); sec=$((10#$sec))
          delta=$(( ( (min - OFFSET) % PERIOD + PERIOD ) % PERIOD ))
          if [ $delta -eq 0 ]; then
            mins_to_next=$PERIOD
          else
            mins_to_next=$(( PERIOD - delta ))
          fi
          secs_to_next=$(( mins_to_next*60 - sec ))
          budget=$(( secs_to_next - MARGIN ))
          if [ $budget -le 15 ]; then budget=15; fi   # budget minimal de sécurité

          DEADLINE_TS=$(( now_ts + budget ))
          log "[scheduler] Next nominal tick in ${secs_to_next}s -> using budget=${budget}s (until $(date -u -d "@$DEADLINE_TS" +%H:%M:%S)Z)"

          # === Tentative unique : 0=OK, 129=TooManyRequests(429), 130=Out of capacity, autre=échec générique ===
          try_launch(){
            local DISPLAY_NAME="$1" COMPARTMENT_ID="$2" SUBNET_ID="$3" IMAGE_ID="$4" OCPUS="$5" MEM_GB="$6" \
                  BOOT_SIZE_GB="$7" BOOT_VPUS_PER_GB="$8" ASSIGN_PUBLIC_IP="$9" SSH_AUTH_KEYS="${10}"

            # skip si instance déjà présente (non TERMINATED)
            local EXISTING
            EXISTING="$(oci compute instance list --compartment-id "$COMPARTMENT_ID" --all \
              --query "data[?\"display-name\"=='$DISPLAY_NAME' && \`lifecycle-state\`!='TERMINATED'].id | [0]" \
              --raw-output || true)"
            if [ -n "${EXISTING:-}" ] && [ "${EXISTING:-null}" != "null" ]; then
              log "[$DISPLAY_NAME] skip (déjà présente)"
              return 0
            fi

            # JSON temp
            WORKDIR="$(mktemp -d)"; trap 'rm -rf "$WORKDIR"' RETURN
            printf '%s\n' '{ "areLegacyImdsEndpointsDisabled": false }' > "$WORKDIR/instanceOptions.json"
            printf '%s\n' '{ "recoveryAction": "RESTORE_INSTANCE" }' > "$WORKDIR/availabilityConfig.json"
            printf '%s\n' '{
              "isManagementDisabled": false,
              "isMonitoringDisabled": false,
              "pluginsConfig": [
                {"name":"Vulnerability Scanning","desiredState":"DISABLED"},
                {"name":"Management Agent","desiredState":"DISABLED"},
                {"name":"Custom Logs Monitoring","desiredState":"ENABLED"},
                {"name":"Compute RDMA GPU Monitoring","desiredState":"DISABLED"},
                {"name":"Compute Instance Monitoring","desiredState":"ENABLED"},
                {"name":"Compute HPC RDMA Auto-Configuration","desiredState":"DISABLED"},
                {"name":"Compute HPC RDMA Authentication","desiredState":"DISABLED"},
                {"name":"Cloud Guard Workload Protection","desiredState":"ENABLED"},
                {"name":"Block Volume Management","desiredState":"DISABLED"},
                {"name":"Bastion","desiredState":"DISABLED"}
              ]
            }' > "$WORKDIR/agentConfig.json"
            printf '{ "sourceType": "image", "imageId": "%s", "bootVolumeSizeInGBs": %s, "bootVolumeVpusPerGB": %s }\n' \
              "$IMAGE_ID" "$BOOT_SIZE_GB" "$BOOT_VPUS_PER_GB" > "$WORKDIR/sourceDetails.json"
            printf '{ "ocpus": %s, "memoryInGBs": %s }\n' "$OCPUS" "$MEM_GB" > "$WORKDIR/shapeConfig.json"

            # Lancer et capturer stderr
            OCI_ERR="$WORKDIR/err.log"
            set +e
            oci compute instance launch \
              --availability-domain "$AD_NAME" \
              --compartment-id "$COMPARTMENT_ID" \
              --display-name "$DISPLAY_NAME" \
              --shape "VM.Standard.A1.Flex" \
              --shape-config "file://$WORKDIR/shapeConfig.json" \
              --source-details "file://$WORKDIR/sourceDetails.json" \
              --availability-config "file://$WORKDIR/availabilityConfig.json" \
              --instance-options "file://$WORKDIR/instanceOptions.json" \
              --agent-config "file://$WORKDIR/agentConfig.json" \
              --subnet-id "$SUBNET_ID" \
              --assign-public-ip "$ASSIGN_PUBLIC_IP" \
              --metadata "{\"ssh_authorized_keys\":\"$SSH_AUTH_KEYS\"}" \
              2> "$OCI_ERR"
            rc=$?
            set -e

            if [ $rc -eq 0 ]; then
              return 0
            fi

            # Log d'erreur complet
            log "[$DISPLAY_NAME] OCI error (exit=$rc) — full stderr below:"
            sed 's/^/    /' "$OCI_ERR" || true

            if grep -qi 'TooManyRequests' "$OCI_ERR"; then
              return 129
            fi
            if grep -qi 'out of host capacity\|out of capacity' "$OCI_ERR"; then
              return 130
            fi
            return $rc
          }

          # === Boucle jusqu'à la DEADLINE dynamique ===
          launch_until_deadline(){
            local DEADLINE="$1"; shift
            local NAME="$1"; shift
            local now attempt=1 status delay
            while true; do
              now="$(date -u +%s)"
              if [ "$now" -ge "$DEADLINE" ]; then
                log "[$NAME] deadline reached — stop for this run"
                return 1
              fi
              log "[$NAME] attempt $attempt (time left: $((DEADLINE - now))s)"
              if try_launch "$@"; then
                log "[$NAME] OK"
                return 0
              fi
              status=$?
              if [ $status -eq 129 ]; then
                delay=$(( 60 + (RANDOM % JITTER_MAX_SEC) ))
                log "[$NAME] 429 TooManyRequests — pause ${delay}s"
                sleep "$delay"
              else
                sleep "$SLEEP_BETWEEN_ATTEMPTS_SEC"
              fi
              attempt=$((attempt+1))
            done
          }

          # === VM1 puis VM2 dans le temps restant ===
          if launch_until_deadline \
              "$DEADLINE_TS" \
              "$VM1_DISPLAY_NAME" \
              "$VM1_DISPLAY_NAME" "$VM1_COMPARTMENT_ID" "$VM1_SUBNET_ID" "$VM1_IMAGE_ID" \
              "$VM1_OCPUS" "$VM1_MEM_GB" "$VM1_BOOT_SIZE_GB" "$VM1_BOOT_VPUS_PER_GB" "$VM1_ASSIGN_PUBLIC_IP" \
              "$VM1_SSH_AUTH_KEYS"; then

            if ! launch_until_deadline \
                "$DEADLINE_TS" \
                "$VM2_DISPLAY_NAME" \
                "$VM2_DISPLAY_NAME" "$VM2_COMPARTMENT_ID" "$VM2_SUBNET_ID" "$VM2_IMAGE_ID" \
                "$VM2_OCPUS" "$VM2_MEM_GB" "$VM2_BOOT_SIZE_GB" "$VM2_BOOT_VPUS_PER_GB" "$VM2_ASSIGN_PUBLIC_IP" \
                "$VM2_SSH_AUTH_KEYS"; then
              log "[${VM2_DISPLAY_NAME}] FAIL — retry au prochain cron"
            fi
          else
            log "[gate] VM1 non créée dans la fenêtre — pas de tentative VM2"
            exit 1
          fi

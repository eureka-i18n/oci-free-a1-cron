name: oci-free-a1-retry

on:
  workflow_dispatch: {}   

permissions:
  contents: read

jobs:
  launch:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    concurrency:
      group: oci-free-a1-retry
      cancel-in-progress: true

    env:
      # ===== VM1 =====
      VM1_DISPLAY_NAME: ${{ secrets.VM1_DISPLAY_NAME }}
      VM1_COMPARTMENT_ID: ${{ secrets.VM1_COMPARTMENT_ID }}
      VM1_SUBNET_ID: ${{ secrets.VM1_SUBNET_ID }}
      VM1_IMAGE_ID: ${{ secrets.VM1_IMAGE_ID }}
      VM1_OCPUS: "2"
      VM1_MEM_GB: "10"
      VM1_BOOT_SIZE_GB: "50"
      VM1_BOOT_VPUS_PER_GB: "10"
      VM1_ASSIGN_PUBLIC_IP: "false"
      VM1_SSH_AUTH_KEYS: ${{ secrets.SSH_AUTH_KEYS }}

      # ===== VM2 =====
      VM2_DISPLAY_NAME: ${{ secrets.VM2_DISPLAY_NAME }}
      VM2_COMPARTMENT_ID: ${{ secrets.VM1_COMPARTMENT_ID }}
      VM2_SUBNET_ID: ${{ secrets.VM1_SUBNET_ID }}
      VM2_IMAGE_ID: ${{ secrets.VM1_IMAGE_ID }}
      VM2_OCPUS: "2"
      VM2_MEM_GB: "14"
      VM2_BOOT_SIZE_GB: "50"
      VM2_BOOT_VPUS_PER_GB: "10"
      VM2_ASSIGN_PUBLIC_IP: "false"
      VM2_SSH_AUTH_KEYS: ${{ secrets.SSH_AUTH_KEYS }}

      # ===== Global =====
      AD_NAME: ${{ secrets.AD_NAME }}
      RETRIES: "4"
      BASE_DELAY_SEC: "15"
      JITTER_MAX_SEC: "8"

    steps:
      - name: Setup OCI CLI
        env:
          OCI_TENANCY_OCID: ${{ secrets.OCI_TENANCY_OCID }}
          OCI_USER_OCID: ${{ secrets.OCI_USER_OCID }}
          OCI_FINGERPRINT: ${{ secrets.OCI_FINGERPRINT }}
          OCI_REGION: ${{ secrets.OCI_REGION }}
          OCI_PRIVATE_KEY: ${{ secrets.OCI_PRIVATE_KEY }}
        shell: bash
        run: |
          set -euo pipefail
          python3 -m pip install --user --upgrade oci-cli
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          mkdir -p ~/.oci
          printf "[DEFAULT]\nuser=%s\ntenancy=%s\nfingerprint=%s\nregion=%s\nkey_file=%s\n" \
            "$OCI_USER_OCID" "$OCI_TENANCY_OCID" "$OCI_FINGERPRINT" "$OCI_REGION" "$HOME/.oci/oci_api_key.pem" \
            > ~/.oci/config
          umask 177 && printf "%s" "$OCI_PRIVATE_KEY" > ~/.oci/oci_api_key.pem
          oci -v

      - name: Launch VM1 then VM2
        shell: bash
        run: |
          set -euo pipefail
          log(){ printf "%s %s\n" "$(date -Is)" "$*"; }

          try_launch(){
            local DISPLAY_NAME="$1" COMPARTMENT_ID="$2" SUBNET_ID="$3" IMAGE_ID="$4" OCPUS="$5" MEM_GB="$6" \
                  BOOT_SIZE_GB="$7" BOOT_VPUS_PER_GB="$8" ASSIGN_PUBLIC_IP="$9" SSH_AUTH_KEYS="${10}"

            local EXISTING
            EXISTING="$(oci compute instance list --compartment-id "$COMPARTMENT_ID" --all \
              --query "data[?\"display-name\"=='$DISPLAY_NAME' && \`lifecycle-state\`!='TERMINATED'].id | [0]" \
              --raw-output || true)"
            if [ -n "${EXISTING:-}" ] && [ "${EXISTING:-null}" != "null" ]; then
              log "[$DISPLAY_NAME] skip (déjà présente)"
              return 0
            fi

            WORKDIR="$(mktemp -d)"; trap 'rm -rf "$WORKDIR"' RETURN
            printf '%s\n' '{ "areLegacyImdsEndpointsDisabled": false }' > "$WORKDIR/instanceOptions.json"
            printf '%s\n' '{ "recoveryAction": "RESTORE_INSTANCE" }' > "$WORKDIR/availabilityConfig.json"
            printf '%s\n' '{
              "isManagementDisabled": false,
              "isMonitoringDisabled": false,
              "pluginsConfig": [
                {"name":"Vulnerability Scanning","desiredState":"DISABLED"},
                {"name":"Management Agent","desiredState":"DISABLED"},
                {"name":"Custom Logs Monitoring","desiredState":"ENABLED"},
                {"name":"Compute RDMA GPU Monitoring","desiredState":"DISABLED"},
                {"name":"Compute Instance Monitoring","desiredState":"ENABLED"},
                {"name":"Compute HPC RDMA Auto-Configuration","desiredState":"DISABLED"},
                {"name":"Compute HPC RDMA Authentication","desiredState":"DISABLED"},
                {"name":"Cloud Guard Workload Protection","desiredState":"ENABLED"},
                {"name":"Block Volume Management","desiredState":"DISABLED"},
                {"name":"Bastion","desiredState":"DISABLED"}
              ]
            }' > "$WORKDIR/agentConfig.json"
            printf '{ "sourceType": "image", "imageId": "%s", "bootVolumeSizeInGBs": %s, "bootVolumeVpusPerGB": %s }\n' \
              "$IMAGE_ID" "$BOOT_SIZE_GB" "$BOOT_VPUS_PER_GB" > "$WORKDIR/sourceDetails.json"
            printf '{ "ocpus": %s, "memoryInGBs": %s }\n' "$OCPUS" "$MEM_GB" > "$WORKDIR/shapeConfig.json"

            OCI_ERR="$WORKDIR/err.log"
            set +e
            oci compute instance launch \
              --availability-domain "$AD_NAME" \
              --compartment-id "$COMPARTMENT_ID" \
              --display-name "$DISPLAY_NAME" \
              --shape "VM.Standard.A1.Flex" \
              --shape-config "file://$WORKDIR/shapeConfig.json" \
              --source-details "file://$WORKDIR/sourceDetails.json" \
              --availability-config "file://$WORKDIR/availabilityConfig.json" \
              --instance-options "file://$WORKDIR/instanceOptions.json" \
              --agent-config "file://$WORKDIR/agentConfig.json" \
              --subnet-id "$SUBNET_ID" \
              --assign-public-ip "$ASSIGN_PUBLIC_IP" \
              --metadata "{\"ssh_authorized_keys\":\"$SSH_AUTH_KEYS\"}" \
              2> "$OCI_ERR"
            rc=$?
            set -e

            if [ $rc -eq 0 ]; then
              return 0
            fi
            log "[$DISPLAY_NAME] OCI error (exit=$rc) — full stderr below:"
            sed 's/^/    /' "$OCI_ERR" || true
            if grep -qi 'TooManyRequests' "$OCI_ERR"; then
              return 129
            fi
            if grep -qi 'out of host capacity\|out of capacity' "$OCI_ERR"; then
              return 130
            fi
            return $rc
          }

          launch_with_retries(){
            local NAME="$1"; shift
            local i delay status
            for (( i=1; i<=${RETRIES}; i++ )); do
              log "[$NAME] attempt $i/${RETRIES}"
              if try_launch "$@"; then
                log "[$NAME] OK"
                return 0
              fi
              status=$?
              if [ "$i" -lt "${RETRIES}" ]; then
                if [ $status -eq 129 ]; then
                  delay=$(( i*BASE_DELAY_SEC + 60 + (RANDOM % JITTER_MAX_SEC) ))
                  log "[$NAME] 429 TooManyRequests — pause ${delay}s"
                else
                  delay=$(( i*BASE_DELAY_SEC + (RANDOM % JITTER_MAX_SEC) ))
                  log "[$NAME] waiting ${delay}s"
                fi
                sleep "$delay"
              fi
            done
            log "[$NAME] FAIL after ${RETRIES} attempts"
            return 1
          }

          if launch_with_retries \
              "$VM1_DISPLAY_NAME" \
              "$VM1_DISPLAY_NAME" "$VM1_COMPARTMENT_ID" "$VM1_SUBNET_ID" "$VM1_IMAGE_ID" \
              "$VM1_OCPUS" "$VM1_MEM_GB" "$VM1_BOOT_SIZE_GB" "$VM1_BOOT_VPUS_PER_GB" "$VM1_ASSIGN_PUBLIC_IP" \
              "$VM1_SSH_AUTH_KEYS"; then
            if ! launch_with_retries \
                "$VM2_DISPLAY_NAME" \
                "$VM2_DISPLAY_NAME" "$VM2_COMPARTMENT_ID" "$VM2_SUBNET_ID" "$VM2_IMAGE_ID" \
                "$VM2_OCPUS" "$VM2_MEM_GB" "$VM2_BOOT_SIZE_GB" "$VM2_BOOT_VPUS_PER_GB" "$VM2_ASSIGN_PUBLIC_IP" \
                "$VM2_SSH_AUTH_KEYS"; then
              log "[${VM2_DISPLAY_NAME}] FAIL — retry au prochain dispatch"
            fi
          else
            log "[gate] VM1 non créée — pas de tentative VM2"
            exit 1
          fi
